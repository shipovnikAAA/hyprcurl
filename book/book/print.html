<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>curl-cffi-rs Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to curl-cffi-rs: high-performance HTTP client with browser impersonation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-1aebe933.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-b5446dd1.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">curl-cffi-rs Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/Aditya-PS-05/hyprcurl" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <strong>curl-cffi-rs</strong> guide! This book will teach you everything you need to know about using curl-cffi-rs, a high-performance Rust implementation of curl_cffi with browser fingerprinting support.</p>
<h2 id="what-is-curl-cffi-rs"><a class="header" href="#what-is-curl-cffi-rs">What is curl-cffi-rs?</a></h2>
<p>curl-cffi-rs is a Rust library that provides:</p>
<ul>
<li><strong>Zero-cost abstractions</strong> - Efficient wrapper around libcurl</li>
<li><strong>Type-safe API</strong> - Leverage Rust’s type system for safer HTTP requests</li>
<li><strong>Browser Impersonation</strong> - Mimic real browser TLS fingerprints to avoid bot detection</li>
<li><strong>Async/await support</strong> - First-class async support via tokio</li>
<li><strong>WebSocket support</strong> - Built-in WebSocket client</li>
<li><strong>Python bindings</strong> - Use from Python via PyO3</li>
</ul>
<h2 id="why-curl-cffi-rs"><a class="header" href="#why-curl-cffi-rs">Why curl-cffi-rs?</a></h2>
<p>Modern websites often use sophisticated bot detection mechanisms that analyze TLS fingerprints and HTTP/2 characteristics. curl-cffi-rs uses libcurl-impersonate to mimic real browsers at the TLS level, making it ideal for:</p>
<ul>
<li>Web scraping</li>
<li>API testing</li>
<li>Automation tasks</li>
<li>Research and security testing</li>
</ul>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h2>
<p>This book is for anyone who wants to:</p>
<ul>
<li>Make HTTP requests in Rust with browser-like characteristics</li>
<li>Bypass basic bot detection mechanisms</li>
<li>Build high-performance web scrapers</li>
<li>Use WebSockets with browser impersonation</li>
</ul>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>This book is organized into several sections:</p>
<ul>
<li><strong>Getting Started</strong> - Installation and basic usage</li>
<li><strong>Guide</strong> - Common tasks and features</li>
<li><strong>Advanced</strong> - Async support, WebSockets, and Python bindings</li>
<li><strong>API Reference</strong> - Detailed API documentation</li>
</ul>
<p>You can read the book linearly or jump to specific topics as needed.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>curl-cffi-rs is open source! Contributions are welcome. Visit our <a href="https://github.com/Aditya-PS-05/hyprcurl">GitHub repository</a> to get involved.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This chapter will guide you through installing curl-cffi-rs and its dependencies.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before using curl-cffi-rs, you need:</p>
<ul>
<li><strong>Rust</strong> - Install from <a href="https://rustup.rs/">rustup.rs</a></li>
<li><strong>libcurl-impersonate</strong> - The underlying C library (optional for basic usage)</li>
</ul>
<h2 id="adding-to-your-project"><a class="header" href="#adding-to-your-project">Adding to your project</a></h2>
<p>Add curl-cffi-rs to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
curl-cffi-rs = "0.1"
</code></pre>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h3>
<p>curl-cffi-rs provides several optional features:</p>
<pre><code class="language-toml">[dependencies]
curl-cffi-rs = { version = "0.1", features = ["async"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><strong>async</strong> - Enables async/await support with tokio</li>
<li><strong>python</strong> - Enables Python bindings via PyO3</li>
</ul>
<h3 id="example-with-all-features"><a class="header" href="#example-with-all-features">Example with all features</a></h3>
<pre><code class="language-toml">[dependencies]
curl-cffi-rs = { version = "0.1", features = ["async", "python"] }
</code></pre>
<h2 id="installing-libcurl-impersonate"><a class="header" href="#installing-libcurl-impersonate">Installing libcurl-impersonate</a></h2>
<p>For browser impersonation to work, you need libcurl-impersonate:</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install build-essential

# Clone and build libcurl-impersonate
git clone https://github.com/lwthiker/curl-impersonate
cd curl-impersonate
./configure
make
sudo make install
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<pre><code class="language-bash">brew install curl-impersonate
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows support is experimental. See the <a href="https://github.com/lwthiker/curl-impersonate">libcurl-impersonate documentation</a> for details.</p>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a simple test program to verify everything works:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::Curl;

fn main() {
    let curl = Curl::new().expect("Failed to initialize curl");
    println!("curl-cffi-rs is working! Version: {}", curl_cffi_rs::version());
}</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>If you see the version information, you’re ready to go!</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have curl-cffi-rs installed, continue to the <a href="#quick-start">Quick Start</a> guide to make your first request.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Let’s make your first HTTP request with curl-cffi-rs!</p>
<h2 id="simple-get-request"><a class="header" href="#simple-get-request">Simple GET Request</a></h2>
<p>Here’s the simplest way to fetch a webpage:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn main() -&gt; Result&lt;(), CurlError&gt; {
    // Create a new Curl instance
    let mut curl = Curl::new()?;

    // Set the URL to fetch
    curl.set_url("https://httpbin.org/get")?;

    // Create a buffer to store the response
    let mut response = Vec::new();

    // Perform the request
    curl.perform(&amp;mut response)?;

    // Convert response to string and print
    let body = String::from_utf8_lossy(&amp;response);
    println!("Response: {}", body);

    Ok(())
}</code></pre>
<h2 id="post-request-with-data"><a class="header" href="#post-request-with-data">POST Request with Data</a></h2>
<p>Sending POST data is just as easy:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url("https://httpbin.org/post")?;

    // Set POST data
    curl.set_post_fields(r#"{"name": "curl-cffi-rs", "type": "library"}"#)?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    println!("{}", String::from_utf8_lossy(&amp;response));
    Ok(())
}</code></pre>
<h2 id="adding-headers"><a class="header" href="#adding-headers">Adding Headers</a></h2>
<p>Custom headers are common for API requests:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url("https://httpbin.org/headers")?;

    // Add custom headers
    curl.add_header("Content-Type: application/json")?;
    curl.add_header("Authorization: Bearer YOUR_TOKEN")?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    println!("{}", String::from_utf8_lossy(&amp;response));
    Ok(())
}</code></pre>
<h2 id="browser-impersonation"><a class="header" href="#browser-impersonation">Browser Impersonation</a></h2>
<p>The magic feature - impersonate a real browser:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};
use curl_cffi_rs::types::Browser;

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url("https://tls.peet.ws/api/all")?;

    // Impersonate Chrome 120
    curl.impersonate(Browser::Chrome120)?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    // This will show Chrome's TLS fingerprint!
    println!("{}", String::from_utf8_lossy(&amp;response));
    Ok(())
}</code></pre>
<h2 id="getting-response-info"><a class="header" href="#getting-response-info">Getting Response Info</a></h2>
<p>You can extract metadata about the response:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url("https://httpbin.org/get")?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    // Get response information
    let status_code = curl.get_response_code()?;
    let content_type = curl.get_content_type()?;

    println!("Status: {}", status_code);
    println!("Content-Type: {:?}", content_type);
    println!("Body length: {} bytes", response.len());

    Ok(())
}</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Always handle errors properly:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn fetch_url(url: &amp;str) -&gt; Result&lt;String, CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url(url)?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    String::from_utf8(response)
        .map_err(|e| CurlError::Utf8Error(e.utf8_error()))
}

fn main() {
    match fetch_url("https://httpbin.org/get") {
        Ok(body) =&gt; println!("Success: {}", body),
        Err(e) =&gt; eprintln!("Error: {}", e),
    }
}</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>You now know the basics! Continue to <a href="#basic-usage">Basic Usage</a> to learn more about configuring requests, or jump to the <a href="#making-requests">Guide</a> section for specific use cases.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<p>This chapter covers common patterns and configurations for curl-cffi-rs.</p>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h3>
<p>Set timeouts to prevent requests from hanging:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url("https://httpbin.org/delay/10")?;

    // Set connection timeout (30 seconds)
    curl.set_connect_timeout(30)?;

    // Set total timeout (60 seconds)
    curl.set_timeout(60)?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    Ok(())
}</code></pre>
<h3 id="follow-redirects"><a class="header" href="#follow-redirects">Follow Redirects</a></h3>
<p>Control how redirects are handled:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Redirects are followed by default
let mut curl = Curl::new()?;

// Disable redirects
curl.set_follow_redirects(false)?;

// Set maximum number of redirects
curl.set_max_redirects(5)?;
<span class="boring">}</span></code></pre>
<h3 id="ssltls-options"><a class="header" href="#ssltls-options">SSL/TLS Options</a></h3>
<p>Configure SSL certificate verification:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify SSL certificates (default)
curl.set_ssl_verify(Some(true))?;

// Disable SSL verification (not recommended for production!)
curl.set_ssl_verify(Some(false))?;

// Use custom CA bundle
curl.set_ca_cert("/path/to/cacert.pem")?;
<span class="boring">}</span></code></pre>
<h2 id="working-with-different-http-methods"><a class="header" href="#working-with-different-http-methods">Working with Different HTTP Methods</a></h2>
<h3 id="get-request"><a class="header" href="#get-request">GET Request</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/users")?;
<span class="boring">}</span></code></pre>
<h3 id="post-request"><a class="header" href="#post-request">POST Request</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/users")?;
curl.set_post_fields(r#"{"name": "John"}"#)?;
<span class="boring">}</span></code></pre>
<h3 id="put-request"><a class="header" href="#put-request">PUT Request</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use curl_cffi_rs::types::CurlOpt;

let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/users/1")?;
curl.set_custom_request("PUT")?;
curl.set_post_fields(r#"{"name": "Jane"}"#)?;
<span class="boring">}</span></code></pre>
<h3 id="delete-request"><a class="header" href="#delete-request">DELETE Request</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/users/1")?;
curl.set_custom_request("DELETE")?;
<span class="boring">}</span></code></pre>
<h2 id="response-handling"><a class="header" href="#response-handling">Response Handling</a></h2>
<h3 id="accessing-response-data"><a class="header" href="#accessing-response-data">Accessing Response Data</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://httpbin.org/json")?;

let mut response = Vec::new();
curl.perform(&amp;mut response)?;

// Parse JSON response
let json: serde_json::Value = serde_json::from_slice(&amp;response)?;
println!("{:#?}", json);
<span class="boring">}</span></code></pre>
<h3 id="getting-response-metadata"><a class="header" href="#getting-response-metadata">Getting Response Metadata</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.perform(&amp;mut response)?;

// HTTP status code
let status = curl.get_response_code()?;

// Content type
let content_type = curl.get_content_type()?;

// Download size
let download_size = curl.get_download_size()?;

// Total time
let total_time = curl.get_total_time()?;

println!("Status: {}, Type: {:?}, Size: {} bytes, Time: {:.2}s",
         status, content_type, download_size, total_time);
<span class="boring">}</span></code></pre>
<h2 id="reusing-curl-handles"><a class="header" href="#reusing-curl-handles">Reusing Curl Handles</a></h2>
<p>Reuse the same Curl instance for multiple requests (connection pooling):</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;

// First request
curl.set_url("https://httpbin.org/get")?;
let mut response1 = Vec::new();
curl.perform(&amp;mut response1)?;

// Second request (reuses connection)
curl.set_url("https://httpbin.org/headers")?;
let mut response2 = Vec::new();
curl.perform(&amp;mut response2)?;
<span class="boring">}</span></code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="api-client-with-authentication"><a class="header" href="#api-client-with-authentication">API Client with Authentication</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use curl_cffi_rs::{Curl, CurlError};

struct ApiClient {
    base_url: String,
    api_key: String,
}

impl ApiClient {
    fn new(base_url: String, api_key: String) -&gt; Self {
        Self { base_url, api_key }
    }

    fn get(&amp;self, endpoint: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, CurlError&gt; {
        let mut curl = Curl::new()?;
        let url = format!("{}{}", self.base_url, endpoint);
        curl.set_url(&amp;url)?;

        // Add authentication header
        let auth_header = format!("Authorization: Bearer {}", self.api_key);
        curl.add_header(&amp;auth_header)?;

        let mut response = Vec::new();
        curl.perform(&amp;mut response)?;

        Ok(response)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="download-file"><a class="header" href="#download-file">Download File</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Write;

fn download_file(url: &amp;str, path: &amp;str) -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.set_url(url)?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    let mut file = File::create(path)?;
    file.write_all(&amp;response)?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#making-requests">Making Requests</a> in more detail</li>
<li>Explore <a href="#browser-impersonation-1">Browser Impersonation</a></li>
<li>Check out <a href="#error-handling-2">Error Handling</a> best practices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="making-requests"><a class="header" href="#making-requests">Making Requests</a></h1>
<p>This chapter covers the details of making HTTP requests with curl-cffi-rs.</p>
<h2 id="request-methods"><a class="header" href="#request-methods">Request Methods</a></h2>
<p>curl-cffi-rs supports all standard HTTP methods.</p>
<h3 id="get"><a class="header" href="#get">GET</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/data")?;

let mut response = Vec::new();
curl.perform(&amp;mut response)?;
<span class="boring">}</span></code></pre>
<h3 id="post"><a class="header" href="#post">POST</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
curl.set_url("https://api.example.com/data")?;

// JSON data
let data = r#"{"key": "value"}"#;
curl.set_post_fields(data)?;
curl.add_header("Content-Type: application/json")?;

let mut response = Vec::new();
curl.perform(&amp;mut response)?;
<span class="boring">}</span></code></pre>
<h3 id="custom-methods"><a class="header" href="#custom-methods">Custom Methods</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PUT
curl.set_custom_request("PUT")?;

// PATCH
curl.set_custom_request("PATCH")?;

// DELETE
curl.set_custom_request("DELETE")?;
<span class="boring">}</span></code></pre>
<h2 id="request-headers"><a class="header" href="#request-headers">Request Headers</a></h2>
<h3 id="adding-headers-1"><a class="header" href="#adding-headers-1">Adding Headers</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.add_header("User-Agent: MyApp/1.0")?;
curl.add_header("Accept: application/json")?;
curl.add_header("X-Custom-Header: value")?;
<span class="boring">}</span></code></pre>
<h3 id="common-header-patterns"><a class="header" href="#common-header-patterns">Common Header Patterns</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// JSON API
curl.add_header("Content-Type: application/json")?;
curl.add_header("Accept: application/json")?;

// Form data
curl.add_header("Content-Type: application/x-www-form-urlencoded")?;

// Authentication
curl.add_header("Authorization: Bearer YOUR_TOKEN")?;

// CORS
curl.add_header("Origin: https://example.com")?;
<span class="boring">}</span></code></pre>
<h2 id="request-body"><a class="header" href="#request-body">Request Body</a></h2>
<h3 id="json-data"><a class="header" href="#json-data">JSON Data</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::json;

let data = json!({
    "name": "curl-cffi-rs",
    "version": "0.1.0"
});

curl.set_post_fields(&amp;data.to_string())?;
curl.add_header("Content-Type: application/json")?;
<span class="boring">}</span></code></pre>
<h3 id="form-data"><a class="header" href="#form-data">Form Data</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = "username=john&amp;password=secret";
curl.set_post_fields(form_data)?;
curl.add_header("Content-Type: application/x-www-form-urlencoded")?;
<span class="boring">}</span></code></pre>
<h3 id="binary-data"><a class="header" href="#binary-data">Binary Data</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;

let binary_data = fs::read("file.bin")?;
curl.set_post_fields_binary(&amp;binary_data)?;
<span class="boring">}</span></code></pre>
<h2 id="query-parameters"><a class="header" href="#query-parameters">Query Parameters</a></h2>
<h3 id="manual-construction"><a class="header" href="#manual-construction">Manual Construction</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let url = "https://api.example.com/search?q=rust&amp;limit=10";
curl.set_url(url)?;
<span class="boring">}</span></code></pre>
<h3 id="using-url-builder"><a class="header" href="#using-url-builder">Using URL Builder</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use url::Url;

let mut url = Url::parse("https://api.example.com/search")?;
url.query_pairs_mut()
    .append_pair("q", "rust")
    .append_pair("limit", "10");

curl.set_url(url.as_str())?;
<span class="boring">}</span></code></pre>
<h2 id="response-handling-1"><a class="header" href="#response-handling-1">Response Handling</a></h2>
<h3 id="reading-response-body"><a class="header" href="#reading-response-body">Reading Response Body</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut response = Vec::new();
curl.perform(&amp;mut response)?;

let body = String::from_utf8_lossy(&amp;response);
println!("{}", body);
<span class="boring">}</span></code></pre>
<h3 id="parsing-json"><a class="header" href="#parsing-json">Parsing JSON</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;

#[derive(Deserialize)]
struct ApiResponse {
    status: String,
    data: Vec&lt;String&gt;,
}

let mut response = Vec::new();
curl.perform(&amp;mut response)?;

let parsed: ApiResponse = serde_json::from_slice(&amp;response)?;
<span class="boring">}</span></code></pre>
<h3 id="streaming-response"><a class="header" href="#streaming-response">Streaming Response</a></h3>
<p>For large responses, consider processing data as it arrives:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Future feature - streaming support
// Currently, data is buffered in memory
<span class="boring">}</span></code></pre>
<h2 id="connection-options"><a class="header" href="#connection-options">Connection Options</a></h2>
<h3 id="timeouts-1"><a class="header" href="#timeouts-1">Timeouts</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connection timeout (seconds)
curl.set_connect_timeout(30)?;

// Total request timeout (seconds)
curl.set_timeout(60)?;
<span class="boring">}</span></code></pre>
<h3 id="redirects"><a class="header" href="#redirects">Redirects</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Follow redirects (default: true)
curl.set_follow_redirects(true)?;

// Maximum redirects
curl.set_max_redirects(10)?;
<span class="boring">}</span></code></pre>
<h3 id="keep-alive"><a class="header" href="#keep-alive">Keep-Alive</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reuse the same Curl instance for connection pooling
let mut curl = Curl::new()?;

for i in 0..10 {
    curl.set_url(&amp;format!("https://api.example.com/item/{}", i))?;
    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;
    // Connection is reused
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<h3 id="checking-status-codes"><a class="header" href="#checking-status-codes">Checking Status Codes</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.perform(&amp;mut response)?;

let status = curl.get_response_code()?;
if status &gt;= 400 {
    eprintln!("HTTP error: {}", status);
    return Err(CurlError::Other(format!("HTTP {}", status)));
}
<span class="boring">}</span></code></pre>
<h3 id="catching-network-errors"><a class="header" href="#catching-network-errors">Catching Network Errors</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match curl.perform(&amp;mut response) {
    Ok(_) =&gt; println!("Success!"),
    Err(CurlError::CurlCode { code, message }) =&gt; {
        eprintln!("Network error {}: {}", code, message);
    }
    Err(e) =&gt; {
        eprintln!("Other error: {}", e);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#browser-impersonation-1">Browser Impersonation</a> - Mimic real browsers</li>
<li><a href="#ssltls-configuration">SSL/TLS Configuration</a> - Secure connections</li>
<li><a href="#headers-and-cookies">Headers and Cookies</a> - Advanced header management</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="browser-impersonation-1"><a class="header" href="#browser-impersonation-1">Browser Impersonation</a></h1>
<p>One of the most powerful features of curl-cffi-rs is its ability to impersonate real web browsers at the TLS fingerprint level.</p>
<h2 id="why-browser-impersonation"><a class="header" href="#why-browser-impersonation">Why Browser Impersonation?</a></h2>
<p>Modern websites use sophisticated techniques to detect automated clients:</p>
<ul>
<li><strong>TLS Fingerprinting</strong> - Analyzing SSL/TLS handshake characteristics</li>
<li><strong>HTTP/2 Fingerprinting</strong> - Examining HTTP/2 settings and priorities</li>
<li><strong>JA3/JA4 Signatures</strong> - Unique identifiers based on TLS parameters</li>
</ul>
<p>curl-cffi-rs uses libcurl-impersonate to mimic real browsers, making your requests indistinguishable from a real browser at the network level.</p>
<h2 id="supported-browsers"><a class="header" href="#supported-browsers">Supported Browsers</a></h2>
<p>curl-cffi-rs supports impersonating various browsers:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use curl_cffi_rs::types::Browser;

// Chrome versions
Browser::Chrome99
Browser::Chrome100
Browser::Chrome101
Browser::Chrome104
Browser::Chrome107
Browser::Chrome110
Browser::Chrome116
Browser::Chrome119
Browser::Chrome120
Browser::Chrome123
Browser::Chrome124
Browser::Chrome126
Browser::Chrome127
Browser::Chrome128
Browser::Chrome131

// Edge versions
Browser::Edge99
Browser::Edge101

// Safari versions
Browser::Safari15_3
Browser::Safari15_5
Browser::Safari17_0
Browser::Safari17_2_1
Browser::Safari18_0
Browser::SafariIOS17_2
Browser::SafariIOS17_4_1
Browser::SafariIOS18_1_1
<span class="boring">}</span></code></pre>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<h3 id="impersonating-chrome"><a class="header" href="#impersonating-chrome">Impersonating Chrome</a></h3>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};
use curl_cffi_rs::types::Browser;

fn main() -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;

    // Impersonate Chrome 120
    curl.impersonate(Browser::Chrome120)?;

    curl.set_url("https://tls.peet.ws/api/all")?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    println!("{}", String::from_utf8_lossy(&amp;response));
    Ok(())
}</code></pre>
<h3 id="impersonating-safari"><a class="header" href="#impersonating-safari">Impersonating Safari</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.impersonate(Browser::Safari17_0)?;
<span class="boring">}</span></code></pre>
<h3 id="impersonating-edge"><a class="header" href="#impersonating-edge">Impersonating Edge</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.impersonate(Browser::Edge101)?;
<span class="boring">}</span></code></pre>
<h2 id="testing-your-fingerprint"><a class="header" href="#testing-your-fingerprint">Testing Your Fingerprint</a></h2>
<p>You can verify that impersonation is working by checking your TLS fingerprint:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, types::Browser};

fn test_fingerprint(browser: Browser) -&gt; Result&lt;(), CurlError&gt; {
    let mut curl = Curl::new()?;
    curl.impersonate(browser)?;
    curl.set_url("https://tls.peet.ws/api/all")?;

    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    let json: serde_json::Value = serde_json::from_slice(&amp;response)?;

    println!("Browser: {:?}", browser);
    println!("JA3 Fingerprint: {}", json["tls"]["ja3"]);
    println!("JA4 Fingerprint: {}", json["tls"]["ja4"]);
    println!("User Agent: {}", json["http"]["headers"]["user-agent"]);

    Ok(())
}

fn main() {
    test_fingerprint(Browser::Chrome120).unwrap();
    test_fingerprint(Browser::Safari17_0).unwrap();
}</code></pre>
<h2 id="combining-with-custom-headers"><a class="header" href="#combining-with-custom-headers">Combining with Custom Headers</a></h2>
<p>You can combine browser impersonation with custom headers:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;

// Impersonate Chrome 120
curl.impersonate(Browser::Chrome120)?;

// Add custom headers (these override defaults)
curl.add_header("Accept-Language: en-US,en;q=0.9")?;
curl.add_header("Referer: https://google.com")?;

curl.set_url("https://api.example.com")?;
<span class="boring">}</span></code></pre>
<p><strong>Note</strong>: Custom headers are added <em>after</em> impersonation, so they will override the browser’s default headers.</p>
<h2 id="http2-support"><a class="header" href="#http2-support">HTTP/2 Support</a></h2>
<p>Browser impersonation includes HTTP/2 characteristics:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.impersonate(Browser::Chrome120)?;

// HTTP/2 will be used automatically if the server supports it
// You can verify this:
curl.perform(&amp;mut response)?;

let http_version = curl.get_http_version()?;
println!("HTTP Version: {}", http_version);
<span class="boring">}</span></code></pre>
<h2 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h2>
<p>Here’s a complete example scraping a protected website:</p>
<pre class="playground"><code class="language-rust edition2021">use curl_cffi_rs::{Curl, CurlError};
use curl_cffi_rs::types::Browser;

fn scrape_protected_site(url: &amp;str) -&gt; Result&lt;String, CurlError&gt; {
    let mut curl = Curl::new()?;

    // Impersonate latest Chrome
    curl.impersonate(Browser::Chrome131)?;

    // Add realistic headers
    curl.add_header("Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")?;
    curl.add_header("Accept-Language: en-US,en;q=0.5")?;
    curl.add_header("Accept-Encoding: gzip, deflate, br")?;
    curl.add_header("DNT: 1")?;
    curl.add_header("Connection: keep-alive")?;
    curl.add_header("Upgrade-Insecure-Requests: 1")?;
    curl.add_header("Sec-Fetch-Dest: document")?;
    curl.add_header("Sec-Fetch-Mode: navigate")?;
    curl.add_header("Sec-Fetch-Site: none")?;

    // Set timeout
    curl.set_timeout(30)?;

    // Make request
    curl.set_url(url)?;
    let mut response = Vec::new();
    curl.perform(&amp;mut response)?;

    // Check status
    let status = curl.get_response_code()?;
    if status != 200 {
        return Err(CurlError::Other(format!("HTTP {}", status)));
    }

    Ok(String::from_utf8_lossy(&amp;response).to_string())
}

fn main() {
    match scrape_protected_site("https://example.com") {
        Ok(html) =&gt; println!("Downloaded {} bytes", html.len()),
        Err(e) =&gt; eprintln!("Error: {}", e),
    }
}</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Choose the right browser</strong> - Use a common, recent version</li>
<li><strong>Match user agent</strong> - The user agent is set automatically, but verify it matches your needs</li>
<li><strong>Add realistic headers</strong> - Real browsers send many headers</li>
<li><strong>Respect robots.txt</strong> - Browser impersonation doesn’t justify ignoring site policies</li>
<li><strong>Rate limiting</strong> - Don’t hammer servers even if you can bypass detection</li>
</ol>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>While browser impersonation is powerful, it has limitations:</p>
<ul>
<li><strong>JavaScript</strong> - curl-cffi-rs doesn’t execute JavaScript</li>
<li><strong>Browser APIs</strong> - Features like Canvas fingerprinting aren’t replicated</li>
<li><strong>Cookies</strong> - You need to manage cookies manually</li>
<li><strong>Sessions</strong> - Maintain session state yourself</li>
</ul>
<p>For full browser automation, consider tools like Puppeteer or Playwright. Use curl-cffi-rs when you need fast, lightweight requests with realistic network characteristics.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="#ssltls-configuration">SSL/TLS Configuration</a> - Advanced TLS settings</li>
<li><a href="#headers-and-cookies">Headers and Cookies</a> - Managing cookies and headers</li>
<li><a href="#async-support">Async Support</a> - Making concurrent requests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ssltls-configuration"><a class="header" href="#ssltls-configuration">SSL/TLS Configuration</a></h1>
<p>This chapter covers SSL/TLS configuration options in curl-cffi-rs.</p>
<h2 id="ssl-certificate-verification"><a class="header" href="#ssl-certificate-verification">SSL Certificate Verification</a></h2>
<p>By default, curl-cffi-rs verifies SSL certificates to ensure secure connections.</p>
<h3 id="default-behavior"><a class="header" href="#default-behavior">Default Behavior</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;
// SSL verification is enabled by default
curl.set_url("https://example.com")?;
<span class="boring">}</span></code></pre>
<h3 id="disabling-verification-not-recommended"><a class="header" href="#disabling-verification-not-recommended">Disabling Verification (Not Recommended)</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Disable SSL verification (use only for testing!)
curl.set_ssl_verify(Some(false))?;
<span class="boring">}</span></code></pre>
<p><strong>Warning</strong>: Disabling SSL verification makes your connections vulnerable to man-in-the-middle attacks. Only use this for development/testing.</p>
<h3 id="re-enabling-verification"><a class="header" href="#re-enabling-verification">Re-enabling Verification</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.set_ssl_verify(Some(true))?;
<span class="boring">}</span></code></pre>
<h2 id="custom-ca-certificates"><a class="header" href="#custom-ca-certificates">Custom CA Certificates</a></h2>
<h3 id="using-a-custom-ca-bundle"><a class="header" href="#using-a-custom-ca-bundle">Using a Custom CA Bundle</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use a specific CA certificate file
curl.set_ca_cert("/path/to/cacert.pem")?;
<span class="boring">}</span></code></pre>
<h3 id="using-system-ca-store"><a class="header" href="#using-system-ca-store">Using System CA Store</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use the system's CA certificate store (default on most systems)
curl.set_ca_cert(None)?;
<span class="boring">}</span></code></pre>
<h2 id="client-certificates"><a class="header" href="#client-certificates">Client Certificates</a></h2>
<p>For mutual TLS (mTLS), you can provide client certificates:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set client certificate
curl.set_ssl_cert("/path/to/client-cert.pem")?;

// Set client private key
curl.set_ssl_key("/path/to/client-key.pem")?;

// Optional: Set key password
curl.set_ssl_key_password("password")?;
<span class="boring">}</span></code></pre>
<h2 id="tls-versions"><a class="header" href="#tls-versions">TLS Versions</a></h2>
<h3 id="specifying-tls-version"><a class="header" href="#specifying-tls-version">Specifying TLS Version</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use curl_cffi_rs::types::SslVersion;

// Use TLS 1.2 or higher (recommended)
curl.set_ssl_version(SslVersion::TLSv1_2)?;

// Use TLS 1.3 only
curl.set_ssl_version(SslVersion::TLSv1_3)?;

// Let curl decide (default)
curl.set_ssl_version(SslVersion::Default)?;
<span class="boring">}</span></code></pre>
<h2 id="cipher-suites"><a class="header" href="#cipher-suites">Cipher Suites</a></h2>
<h3 id="custom-cipher-list"><a class="header" href="#custom-cipher-list">Custom Cipher List</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Specify custom cipher suites (advanced)
curl.set_ssl_cipher_list("ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384")?;
<span class="boring">}</span></code></pre>
<p><strong>Note</strong>: When using browser impersonation, cipher suites are set automatically to match the target browser.</p>
<h2 id="sni-server-name-indication"><a class="header" href="#sni-server-name-indication">SNI (Server Name Indication)</a></h2>
<p>SNI is enabled by default and uses the hostname from the URL:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SNI is automatic based on URL
curl.set_url("https://example.com")?;
// SNI will send "example.com"
<span class="boring">}</span></code></pre>
<h2 id="pinning-certificates"><a class="header" href="#pinning-certificates">Pinning Certificates</a></h2>
<p>For enhanced security, you can pin specific certificates:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pin a specific certificate (PEM format SHA256)
curl.set_pinnedpublickey("sha256//base64-encoded-hash")?;
<span class="boring">}</span></code></pre>
<p>Example:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.set_pinnedpublickey("sha256//YhKJKSzoTt2b5FP18fvpHo7fJYqQCjAa3HWY3tvRMwE=")?;
<span class="boring">}</span></code></pre>
<h2 id="ocsp-stapling"><a class="header" href="#ocsp-stapling">OCSP Stapling</a></h2>
<p>Enable OCSP stapling for certificate validation:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.set_ssl_verify_status(true)?;
<span class="boring">}</span></code></pre>
<h2 id="common-ssltls-scenarios"><a class="header" href="#common-ssltls-scenarios">Common SSL/TLS Scenarios</a></h2>
<h3 id="corporate-proxy-with-custom-ca"><a class="header" href="#corporate-proxy-with-custom-ca">Corporate Proxy with Custom CA</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;

// Set custom CA bundle
curl.set_ca_cert("/etc/ssl/certs/corporate-ca.pem")?;

// Set proxy
curl.set_proxy("http://proxy.company.com:8080")?;

curl.set_url("https://api.example.com")?;
<span class="boring">}</span></code></pre>
<h3 id="self-signed-certificates-development"><a class="header" href="#self-signed-certificates-development">Self-Signed Certificates (Development)</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;

// Option 1: Disable verification (not recommended)
curl.set_ssl_verify(Some(false))?;

// Option 2: Add self-signed cert to CA bundle (better)
curl.set_ca_cert("/path/to/self-signed-ca.pem")?;

curl.set_url("https://localhost:8443")?;
<span class="boring">}</span></code></pre>
<h3 id="mutual-tls-mtls"><a class="header" href="#mutual-tls-mtls">Mutual TLS (mTLS)</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut curl = Curl::new()?;

// Server CA certificate
curl.set_ca_cert("/path/to/server-ca.pem")?;

// Client certificate and key
curl.set_ssl_cert("/path/to/client-cert.pem")?;
curl.set_ssl_key("/path/to/client-key.pem")?;

curl.set_url("https://mtls.example.com")?;
<span class="boring">}</span></code></pre>
<h2 id="debugging-ssl-issues"><a class="header" href="#debugging-ssl-issues">Debugging SSL Issues</a></h2>
<h3 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable verbose output for debugging
curl.set_verbose(true)?;
<span class="boring">}</span></code></pre>
<p>This will print detailed information about the SSL handshake.</p>
<h3 id="check-certificate-info"><a class="header" href="#check-certificate-info">Check Certificate Info</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>curl.perform(&amp;mut response)?;

// Get certificate chain info (if available)
let cert_info = curl.get_cert_info()?;
println!("Certificate: {:?}", cert_info);
<span class="boring">}</span></code></pre>
<h3 id="common-ssl-errors"><a class="header" href="#common-ssl-errors">Common SSL Errors</a></h3>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match curl.perform(&amp;mut response) {
    Err(CurlError::CurlCode { code: 60, .. }) =&gt; {
        eprintln!("SSL certificate problem: verify that the CA cert is OK");
    }
    Err(CurlError::CurlCode { code: 51, .. }) =&gt; {
        eprintln!("Server's certificate doesn't match the host name");
    }
    Err(CurlError::CurlCode { code: 35, .. }) =&gt; {
        eprintln!("SSL connect error");
    }
    Err(e) =&gt; eprintln!("Other error: {}", e),
    Ok(_) =&gt; println!("Success!"),
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Always verify certificates in production</strong> - Only disable for local development</li>
<li><strong>Keep CA bundles updated</strong> - Old bundles may not trust newer certificates</li>
<li><strong>Use TLS 1.2 or higher</strong> - Older versions have known vulnerabilities</li>
<li><strong>Pin certificates for critical services</strong> - Adds extra layer of security</li>
<li><strong>Test certificate expiration</strong> - Monitor and renew certificates before they expire</li>
</ol>
<h2 id="browser-impersonation-and-ssl"><a class="header" href="#browser-impersonation-and-ssl">Browser Impersonation and SSL</a></h2>
<p>When using browser impersonation, SSL/TLS characteristics are automatically configured:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use curl_cffi_rs::types::Browser;

let mut curl = Curl::new()?;

// This sets TLS version, cipher suites, extensions, etc. automatically
curl.impersonate(Browser::Chrome120)?;

// You can still override SSL settings if needed
curl.set_ca_cert("/custom/ca.pem")?;
<span class="boring">}</span></code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="#headers-and-cookies">Headers and Cookies</a> - Managing request headers and cookies</li>
<li><a href="#browser-impersonation-1">Browser Impersonation</a> - Mimic real browsers</li>
<li><a href="#error-handling-2">Error Handling</a> - Handle SSL errors gracefully</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="headers-and-cookies"><a class="header" href="#headers-and-cookies">Headers and Cookies</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async-support"><a class="header" href="#async-support">Async Support</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="websocket-support"><a class="header" href="#websocket-support">WebSocket Support</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-bindings"><a class="header" href="#python-bindings">Python Bindings</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-api"><a class="header" href="#core-api">Core API</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Content coming soon…</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>Content coming soon…</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>

        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
